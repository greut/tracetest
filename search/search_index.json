{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tracetest Tracetest - Trace-based testing. End-to-end tests powered by your OpenTelemetry Traces. Click on the image or this link to watch the \"Tracetest Intro Video\" video (7 mins) Tracetest allows you to quickly build integration and e2e tests, powered by your OpenTelementry traces. Point the system to your Jaeger or Tempo trace datastore. Define a triggering transaction, such as a GET against an API endpoint. The system runs this transaction, returning both the response data and a full trace. Define tests & assertions against this data, ensuring both your response and the underlying processes worked correctly, quickly, and without errors. Save your test. Run the tests either manually or via your CI build jobs. Blog-posts Check out the following blog-posts with Tracetest-related content: Coming Soon!","title":"Welcome"},{"location":"#tracetest","text":"Tracetest - Trace-based testing. End-to-end tests powered by your OpenTelemetry Traces. Click on the image or this link to watch the \"Tracetest Intro Video\" video (7 mins) Tracetest allows you to quickly build integration and e2e tests, powered by your OpenTelementry traces. Point the system to your Jaeger or Tempo trace datastore. Define a triggering transaction, such as a GET against an API endpoint. The system runs this transaction, returning both the response data and a full trace. Define tests & assertions against this data, ensuring both your response and the underlying processes worked correctly, quickly, and without errors. Save your test. Run the tests either manually or via your CI build jobs.","title":"Tracetest"},{"location":"#blog-posts","text":"Check out the following blog-posts with Tracetest-related content: Coming Soon!","title":"Blog-posts"},{"location":"adding-assertions/","text":"Adding Assertions Assertions may be added to a trace to set a value for a step in the trace to determine success or failure. After you have created a test and your test run is complete, click the Add Assertion button at the bottom right of the trace screen. The Add Assertion dialog opens. You can also create assertions by hovering over the + sign to the right of an attribute in the trace. This will populate the assertion with the correct information for that attribute. The Filter field allows for limiting the spans affected by the assertion.","title":"Adding Assertions"},{"location":"adding-assertions/#adding-assertions","text":"Assertions may be added to a trace to set a value for a step in the trace to determine success or failure. After you have created a test and your test run is complete, click the Add Assertion button at the bottom right of the trace screen. The Add Assertion dialog opens. You can also create assertions by hovering over the + sign to the right of an attribute in the trace. This will populate the assertion with the correct information for that attribute. The Filter field allows for limiting the spans affected by the assertion.","title":"Adding Assertions"},{"location":"advanced-selectors/","text":"Advanced Selectors If you find yourself in a position where you cannot select complex spans, you can use our advanced selectors to help in that task. It enables you selecting spans that are impossible to select using just basic selectors. In order to present each selector feature as easily as possible, we will use a theoretical scenario of an e-commerce application. The system we will inspect has this flow: flowchart LR start((start)) subgraph purchase cart-api purchase-api end subgraph auth auth-api auth-storage[(db)] end subgraph product product-api product-storage[(db)] end subgraph notification notification-api kafka{{kafka}} external-notification-service{{external service}} end start -->|1. Close order| cart-api cart-api-->|5. send buy action| purchase-api purchase-api --> |7. Send notification to user|notification-api purchase-api -->|6. can product be bought by user?| auth-api auth-api --> auth-storage cart-api -->|2. is product available?| product-api product-api -->|4. can user view product?| auth-api product-api -->|3. retrieve product| product-storage notification-api -->|8| kafka kafka -->|9| external-notification-service And it generates the following trace: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K Features Empty selector By providing an empty selector, all spans from the trace are selected. Note that an empty selector is an empty string. Providing span or span[] as a selector will result as a syntax error. Filter by attributes The most basic way of filtering the spans you want to apply an assertion on is by using its attributes. A good starting example would be filtering all spans of type http : span [ tracetest . span . type = \"http\" ] This would select the following spans: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K A:::selectedSpan B:::selectedSpan D:::selectedSpan F:::selectedSpan G:::selectedSpan I:::selectedSpan classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff AND condition If you need to narrow down your results, you can provide multiple properties in the selector by separating them usign a space. So, let's say we want all http spans AND were created by the service cart-api : span [ tracetest . span . type = \"http\" service . name = \"cart-api\" ] This would select the following spans: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K A:::selectedSpan F:::selectedSpan classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff OR condition Sometimes we want to have a broader result by selecting spans that match different selectors. Let's say we have to get all spans from our services, but not from any other external service. span [ service . name = \"api-product\" ], span [ service . name = \"api-auth\" ], span [ service . name = \"api-notification\" ], span [ service . name = \"api-cart\" ] This would select the following spans: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K A:::selectedSpan B:::selectedSpan C:::selectedSpan D:::selectedSpan E:::selectedSpan F:::selectedSpan G:::selectedSpan H:::selectedSpan I:::selectedSpan J:::selectedSpan classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff Each span selector will be executed individually and the results will be merged together, creating a list of all spans that match any of the provided span selectors. Contains operator Although it is possible to filter several span selectors at once to get a broader result, it might become verbose very quickly. The previous example can be written in another way to reduce its complexity: span [ service . name contains \"api\" ] This would select the same spans as the previous example: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K A:::selectedSpan B:::selectedSpan C:::selectedSpan D:::selectedSpan E:::selectedSpan F:::selectedSpan G:::selectedSpan H:::selectedSpan I:::selectedSpan J:::selectedSpan classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff pseudo-classes support Sometimes filtering by attributes is not enough because we might have two or three identical spans in the tree, but we only want to assert one of them. For example, imagine a system that has a retry policy for all the HTTP requests it sends. How would we allow a user to validate if the third execution was successful without asserting the other two spans? This is where pseudo-classes enter the scene. Those are ways of filtering spans by data that is not present in the span itself. For example, the order which the span appears. :warning: Today we support only first , last , and nth_child . If you think we should implement another one, please open an issue and explain why it is important and how it should behave. For the examples of the three pseudo-classes, let's consider we want to select a specific http span based on when it happens. span [ tracetest . span . type = \"http\" ] This will select the following spans: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K A:::selectedSpan B:::selectedSpan D:::selectedSpan F:::selectedSpan G:::selectedSpan I:::selectedSpan classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff :first This would return the first appearing span from the list span [ tracetest . span . type = \"http\" ] : first flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K A:::selectedSpan B:::candidateSpan D:::candidateSpan F:::candidateSpan G:::candidateSpan I:::candidateSpan classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff :last This would return the last appearing span from the list span [ tracetest . span . type = \"http\" ] : last flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K A:::candidateSpan B:::candidateSpan D:::candidateSpan F:::candidateSpan G:::candidateSpan I:::selectedSpan classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff :nth_child This enables you to fetch any item from the list based on its index. n starts at 1 (first element) and ends at length (last element). Any invalid n value will return in an empty list of spans being returned span [ tracetest . span . type = \"http\" ] : nth_child ( 3 ) flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K A:::candidateSpan B:::candidateSpan D:::selectedSpan F:::candidateSpan G:::candidateSpan I:::candidateSpan classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff Parent-child relation filtering Even with all those capabilities, we might have problems with ambiguous selectors returning several spans when just a few were intended. In our example, you can notice that auth-api is called twice from different parts of the trace. At first by product-api and later by cart-api . What if I want to test if a product only available in US can be bought in UK? The product can be seen by the user, but it cannot be bought if the user is outside US. Certainly I cannot apply the same assertions on all auth-api spans, otherwise the test will not pass. :information_source: When you filter by parent-child relation, it matches spans recursively in all levels bellow the parent. This doesn't match only direct children of the parent, but all other spans in the sub-tree. For example: span [ service . name = \"auth-api\" tracetest . span . type = \"http\" ] Will return: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K D:::selectedSpan G:::selectedSpan classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff This is a problem, because if we apply the same assertion to both spans, one of them will fail. We could try to use nth_child but that could break if a http request failed and the retry policy kicked in. Thus, the only way of filtering that is based on the context when it was generated. For example: using its parent span to do so. We could use the purchase products parent to ensure just http class to the auth-api triggered by the purchase-api would be selected: span [ service . name = \"cart-api\" , name = \"purchase products\" ] span [ service . name = \"auth-api\" tracetest . span . type = \"http\" ] This would find the parent span and only select the spans that are descedents of that parent and match the provided filter: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K F:::parentSpan G:::selectedSpan classDef selectedSpan fill:#439846, color:#ffffff classDef parentSpan fill:#3792cb, color:#ffffff","title":"Selectors"},{"location":"advanced-selectors/#advanced-selectors","text":"If you find yourself in a position where you cannot select complex spans, you can use our advanced selectors to help in that task. It enables you selecting spans that are impossible to select using just basic selectors. In order to present each selector feature as easily as possible, we will use a theoretical scenario of an e-commerce application. The system we will inspect has this flow: flowchart LR start((start)) subgraph purchase cart-api purchase-api end subgraph auth auth-api auth-storage[(db)] end subgraph product product-api product-storage[(db)] end subgraph notification notification-api kafka{{kafka}} external-notification-service{{external service}} end start -->|1. Close order| cart-api cart-api-->|5. send buy action| purchase-api purchase-api --> |7. Send notification to user|notification-api purchase-api -->|6. can product be bought by user?| auth-api auth-api --> auth-storage cart-api -->|2. is product available?| product-api product-api -->|4. can user view product?| auth-api product-api -->|3. retrieve product| product-storage notification-api -->|8| kafka kafka -->|9| external-notification-service And it generates the following trace: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K","title":"Advanced Selectors"},{"location":"advanced-selectors/#features","text":"","title":"Features"},{"location":"advanced-selectors/#empty-selector","text":"By providing an empty selector, all spans from the trace are selected. Note that an empty selector is an empty string. Providing span or span[] as a selector will result as a syntax error.","title":"Empty selector"},{"location":"advanced-selectors/#filter-by-attributes","text":"The most basic way of filtering the spans you want to apply an assertion on is by using its attributes. A good starting example would be filtering all spans of type http : span [ tracetest . span . type = \"http\" ] This would select the following spans: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K A:::selectedSpan B:::selectedSpan D:::selectedSpan F:::selectedSpan G:::selectedSpan I:::selectedSpan classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff","title":"Filter by attributes"},{"location":"advanced-selectors/#and-condition","text":"If you need to narrow down your results, you can provide multiple properties in the selector by separating them usign a space. So, let's say we want all http spans AND were created by the service cart-api : span [ tracetest . span . type = \"http\" service . name = \"cart-api\" ] This would select the following spans: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K A:::selectedSpan F:::selectedSpan classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff","title":"AND condition"},{"location":"advanced-selectors/#or-condition","text":"Sometimes we want to have a broader result by selecting spans that match different selectors. Let's say we have to get all spans from our services, but not from any other external service. span [ service . name = \"api-product\" ], span [ service . name = \"api-auth\" ], span [ service . name = \"api-notification\" ], span [ service . name = \"api-cart\" ] This would select the following spans: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K A:::selectedSpan B:::selectedSpan C:::selectedSpan D:::selectedSpan E:::selectedSpan F:::selectedSpan G:::selectedSpan H:::selectedSpan I:::selectedSpan J:::selectedSpan classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff Each span selector will be executed individually and the results will be merged together, creating a list of all spans that match any of the provided span selectors.","title":"OR condition"},{"location":"advanced-selectors/#contains-operator","text":"Although it is possible to filter several span selectors at once to get a broader result, it might become verbose very quickly. The previous example can be written in another way to reduce its complexity: span [ service . name contains \"api\" ] This would select the same spans as the previous example: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K A:::selectedSpan B:::selectedSpan C:::selectedSpan D:::selectedSpan E:::selectedSpan F:::selectedSpan G:::selectedSpan H:::selectedSpan I:::selectedSpan J:::selectedSpan classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff","title":"Contains operator"},{"location":"advanced-selectors/#pseudo-classes-support","text":"Sometimes filtering by attributes is not enough because we might have two or three identical spans in the tree, but we only want to assert one of them. For example, imagine a system that has a retry policy for all the HTTP requests it sends. How would we allow a user to validate if the third execution was successful without asserting the other two spans? This is where pseudo-classes enter the scene. Those are ways of filtering spans by data that is not present in the span itself. For example, the order which the span appears. :warning: Today we support only first , last , and nth_child . If you think we should implement another one, please open an issue and explain why it is important and how it should behave. For the examples of the three pseudo-classes, let's consider we want to select a specific http span based on when it happens. span [ tracetest . span . type = \"http\" ] This will select the following spans: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K A:::selectedSpan B:::selectedSpan D:::selectedSpan F:::selectedSpan G:::selectedSpan I:::selectedSpan classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff","title":"pseudo-classes support"},{"location":"advanced-selectors/#first","text":"This would return the first appearing span from the list span [ tracetest . span . type = \"http\" ] : first flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K A:::selectedSpan B:::candidateSpan D:::candidateSpan F:::candidateSpan G:::candidateSpan I:::candidateSpan classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff","title":":first"},{"location":"advanced-selectors/#last","text":"This would return the last appearing span from the list span [ tracetest . span . type = \"http\" ] : last flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K A:::candidateSpan B:::candidateSpan D:::candidateSpan F:::candidateSpan G:::candidateSpan I:::selectedSpan classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff","title":":last"},{"location":"advanced-selectors/#nth_child","text":"This enables you to fetch any item from the list based on its index. n starts at 1 (first element) and ends at length (last element). Any invalid n value will return in an empty list of spans being returned span [ tracetest . span . type = \"http\" ] : nth_child ( 3 ) flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K A:::candidateSpan B:::candidateSpan D:::selectedSpan F:::candidateSpan G:::candidateSpan I:::candidateSpan classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff","title":":nth_child"},{"location":"advanced-selectors/#parent-child-relation-filtering","text":"Even with all those capabilities, we might have problems with ambiguous selectors returning several spans when just a few were intended. In our example, you can notice that auth-api is called twice from different parts of the trace. At first by product-api and later by cart-api . What if I want to test if a product only available in US can be bought in UK? The product can be seen by the user, but it cannot be bought if the user is outside US. Certainly I cannot apply the same assertions on all auth-api spans, otherwise the test will not pass. :information_source: When you filter by parent-child relation, it matches spans recursively in all levels bellow the parent. This doesn't match only direct children of the parent, but all other spans in the sub-tree. For example: span [ service . name = \"auth-api\" tracetest . span . type = \"http\" ] Will return: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K D:::selectedSpan G:::selectedSpan classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff This is a problem, because if we apply the same assertion to both spans, one of them will fail. We could try to use nth_child but that could break if a http request failed and the retry policy kicked in. Thus, the only way of filtering that is based on the context when it was generated. For example: using its parent span to do so. We could use the purchase products parent to ensure just http class to the auth-api triggered by the purchase-api would be selected: span [ service . name = \"cart-api\" , name = \"purchase products\" ] span [ service . name = \"auth-api\" tracetest . span . type = \"http\" ] This would find the parent span and only select the spans that are descedents of that parent and match the provided filter: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K F:::parentSpan G:::selectedSpan classDef selectedSpan fill:#439846, color:#ffffff classDef parentSpan fill:#3792cb, color:#ffffff","title":"Parent-child relation filtering"},{"location":"architecture/","text":"Architecture The diagram below shows the underlying Tracetest architecture.","title":"Architecture"},{"location":"architecture/#architecture","text":"The diagram below shows the underlying Tracetest architecture.","title":"Architecture"},{"location":"create-test/","text":"Create a Test Open the Tracetest application . Click the Create Test button and the Create New Test dialog appears: Use the Choose Example drop down list to populate the dialog screen and create a test for the following: List (Get) - List the current Pokemon. Add (Post) - Create any Pokemon - name it, give it a type and set an image for it. Import (Post) - Set a pokemon ID and retrieve all the information from that Pokemon using pokeapi.co. Only Pokemons that exist in the games can be imported. Or input your own test details. The screenshot below shows one of the examples from the Tracetest GitHub Readme document. Then click Create . The trace will start: When the trace is finished, you will get the following results: The trace results include: A diagram of the trace steps that can be viewed in diagram or timeline form by toggling the icons at the top left of the image below. This panel also contains a search field which can be useful when working with large diagrams and timelines. The span details of the trace:","title":"Creating Tests"},{"location":"create-test/#create-a-test","text":"Open the Tracetest application . Click the Create Test button and the Create New Test dialog appears: Use the Choose Example drop down list to populate the dialog screen and create a test for the following: List (Get) - List the current Pokemon. Add (Post) - Create any Pokemon - name it, give it a type and set an image for it. Import (Post) - Set a pokemon ID and retrieve all the information from that Pokemon using pokeapi.co. Only Pokemons that exist in the games can be imported. Or input your own test details. The screenshot below shows one of the examples from the Tracetest GitHub Readme document. Then click Create . The trace will start: When the trace is finished, you will get the following results: The trace results include: A diagram of the trace steps that can be viewed in diagram or timeline form by toggling the icons at the top left of the image below. This panel also contains a search field which can be useful when working with large diagrams and timelines. The span details of the trace:","title":"Create a Test"},{"location":"development/","text":"Development Guide The phiolosphy used to build the frontend is based on object composition and functional programming principles, as well as following the idea of \"code that is updated together should be together\" as much as we can. To achieve this the main funcionality is divided into the following concepts: Gateways Interfaces to the outbound backend services and the browser. Used by Components, Services. Models Encapsulate a set of attributes and modules. Used by Services, APIs. Services Define and drive the Business logic functionality Used by Components, Selectors. Factories Component Facades that allow rendering different versions depending on the use case. Used by Components. Selectors Parse, aggregate and clean data across the app. Used by Components. Styling Framework For styling and web components the main framework in use is Ant Design . Web Folder Structure Web Folder Tree public/ src/ components/ gateways/ assets/ hooks/ constants/ entities/ navigation/ pages/ redux/ types/ utils/ Folder Description public/ contains html and can put any scripts, or static files assets/ contains icons, images or any other private non-code file used in the app gateways/ any API connector components/ any reusable components hooks/ any reusable hooks constants/ any constants navigation/ react-router setup pages/ each page has its folder that contains styled file, and sub components redux/ state management setup entities/ each entity from the application has its own folder containing services, models, gateways, etc types/ defined models used in the web app utils/ any pure functions that shared in the app File Types Type Exstension Example Service .service.ts Span.service.ts Model .model.ts Span.model.ts Factory .factory.tsx Diagram.factory.tsx Component .tsx Input.tsx Styled Components .styled.ts(x) HomePage.styled.ts Selectors .selectors.ts Span.selectors.ts Gateways .gateway.ts TestApi.gateway.ts Test .test.ts Span.test.ts Constants .constants.ts Trace.constants.ts Types .types.ts Assertion.types.ts","title":"Development"},{"location":"development/#development-guide","text":"The phiolosphy used to build the frontend is based on object composition and functional programming principles, as well as following the idea of \"code that is updated together should be together\" as much as we can. To achieve this the main funcionality is divided into the following concepts: Gateways Interfaces to the outbound backend services and the browser. Used by Components, Services. Models Encapsulate a set of attributes and modules. Used by Services, APIs. Services Define and drive the Business logic functionality Used by Components, Selectors. Factories Component Facades that allow rendering different versions depending on the use case. Used by Components. Selectors Parse, aggregate and clean data across the app. Used by Components.","title":"Development Guide"},{"location":"development/#styling-framework","text":"For styling and web components the main framework in use is Ant Design .","title":"Styling Framework"},{"location":"development/#web-folder-structure","text":"","title":"Web Folder Structure"},{"location":"development/#web-folder-tree","text":"public/ src/ components/ gateways/ assets/ hooks/ constants/ entities/ navigation/ pages/ redux/ types/ utils/ Folder Description public/ contains html and can put any scripts, or static files assets/ contains icons, images or any other private non-code file used in the app gateways/ any API connector components/ any reusable components hooks/ any reusable hooks constants/ any constants navigation/ react-router setup pages/ each page has its folder that contains styled file, and sub components redux/ state management setup entities/ each entity from the application has its own folder containing services, models, gateways, etc types/ defined models used in the web app utils/ any pure functions that shared in the app","title":"Web Folder Tree"},{"location":"development/#file-types","text":"Type Exstension Example Service .service.ts Span.service.ts Model .model.ts Span.model.ts Factory .factory.tsx Diagram.factory.tsx Component .tsx Input.tsx Styled Components .styled.ts(x) HomePage.styled.ts Selectors .selectors.ts Span.selectors.ts Gateways .gateway.ts TestApi.gateway.ts Test .test.ts Span.test.ts Constants .constants.ts Trace.constants.ts Types .types.ts Assertion.types.ts","title":"File Types"},{"location":"getting-started/","text":"Getting Started Please follow the install steps for the first installation of Tracetest. Once installed, you can get started by launching the Tracetest Dashboard by following these instructions: Run: kubectl port-forward svc/tracetest 8080 Then launch a browser to http://localhost:8080/ . To learn how to create your first test, see create a test .","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Please follow the install steps for the first installation of Tracetest. Once installed, you can get started by launching the Tracetest Dashboard by following these instructions: Run: kubectl port-forward svc/tracetest 8080 Then launch a browser to http://localhost:8080/ . To learn how to create your first test, see create a test .","title":"Getting Started"},{"location":"installing/","text":"Installation During the setup, we'll deploy Tracetest and Postgres with Helm. For the architectural overview of the components, please check the Architecture page. Prerequsities Installation Requirements Tools needed for the installation: Helm v3 Kubectl Installation Install script We provide a simple install script that can install all required components: curl -L https://raw.githubusercontent.com/kubeshop/tracetest/main/setup.sh | bash -s This command will install Tracetest using the default settings. You can configure the following options: Option description Default value --help show help message n/a --namespace target installation k8s namespace tracetest --trace-backend trace backend (jaeger or tempo) jaeger --trace-backend-endpoint trace backend endpoint jaeger-query:16685 --skip-pma if set, don't install the sample application n/a --skip-backend if set, don't install the jaeger backend n/a Example with custom options: curl -L https://raw.githubusercontent.com/kubeshop/tracetest/main/setup.sh | bash -s -- --skip-pma --namespace my-custom-namespace Using Helm Container images are hosted on the Docker Hub Tracetest repository . Tracetest currently supports two traces backend: Jaeger and Grafana Tempo. Jaeger Tracetest uses Jaeger Query Service 16685 port to find Traces using gRPC protocol. The commands below will install Tracetest connecting to the Jaeger tracing backend on jaeger-query:16685 . # Install Kubeshop Helm repo and update it helm repo add kubeshop https://kubeshop.github.io/helm-charts helm repo update helm install tracetest kubeshop/tracetest \\ --set tracingBackend = jaeger \\ --set jaegerConnectionConfig.endpoint = \"jaeger-query:16685\" # update this value to point to your jaeger install Grafana Tempo Tracetest uses Grafana Tempo's Server's 9095 port to find Traces using gRPC protocol. The commands below will install the Tracetest application connecting to the Grafana Tempo tracing backend on grafana-tempo:9095 : # Install Kubeshop Helm repo and update it helm repo add kubeshop https://kubeshop.github.io/helm-charts helm repo update helm install tracetest kubeshop/tracetest \\ --set tracingBackend = tempo \\ --set tempoConnectionConfig.endpoint = \"grafana-tempo:9095\" # update this value to point to your tempo install Uninstallation The following command will uninstall Tracetest with Postgres: helm delete tracetest","title":"Installation"},{"location":"installing/#installation","text":"During the setup, we'll deploy Tracetest and Postgres with Helm. For the architectural overview of the components, please check the Architecture page.","title":"Installation"},{"location":"installing/#prerequsities","text":"","title":"Prerequsities"},{"location":"installing/#installation-requirements","text":"Tools needed for the installation: Helm v3 Kubectl","title":"Installation Requirements"},{"location":"installing/#installation_1","text":"","title":"Installation"},{"location":"installing/#install-script","text":"We provide a simple install script that can install all required components: curl -L https://raw.githubusercontent.com/kubeshop/tracetest/main/setup.sh | bash -s This command will install Tracetest using the default settings. You can configure the following options: Option description Default value --help show help message n/a --namespace target installation k8s namespace tracetest --trace-backend trace backend (jaeger or tempo) jaeger --trace-backend-endpoint trace backend endpoint jaeger-query:16685 --skip-pma if set, don't install the sample application n/a --skip-backend if set, don't install the jaeger backend n/a Example with custom options: curl -L https://raw.githubusercontent.com/kubeshop/tracetest/main/setup.sh | bash -s -- --skip-pma --namespace my-custom-namespace","title":"Install script"},{"location":"installing/#using-helm","text":"Container images are hosted on the Docker Hub Tracetest repository . Tracetest currently supports two traces backend: Jaeger and Grafana Tempo.","title":"Using Helm"},{"location":"installing/#jaeger","text":"Tracetest uses Jaeger Query Service 16685 port to find Traces using gRPC protocol. The commands below will install Tracetest connecting to the Jaeger tracing backend on jaeger-query:16685 . # Install Kubeshop Helm repo and update it helm repo add kubeshop https://kubeshop.github.io/helm-charts helm repo update helm install tracetest kubeshop/tracetest \\ --set tracingBackend = jaeger \\ --set jaegerConnectionConfig.endpoint = \"jaeger-query:16685\" # update this value to point to your jaeger install","title":"Jaeger"},{"location":"installing/#grafana-tempo","text":"Tracetest uses Grafana Tempo's Server's 9095 port to find Traces using gRPC protocol. The commands below will install the Tracetest application connecting to the Grafana Tempo tracing backend on grafana-tempo:9095 : # Install Kubeshop Helm repo and update it helm repo add kubeshop https://kubeshop.github.io/helm-charts helm repo update helm install tracetest kubeshop/tracetest \\ --set tracingBackend = tempo \\ --set tempoConnectionConfig.endpoint = \"grafana-tempo:9095\" # update this value to point to your tempo install","title":"Grafana Tempo"},{"location":"installing/#uninstallation","text":"The following command will uninstall Tracetest with Postgres: helm delete tracetest","title":"Uninstallation"},{"location":"openapi/","text":"const ui = SwaggerUIBundle({ url: 'https://raw.githubusercontent.com/kubeshop/tracetest/main/api/openapi.yaml', dom_id: '#swagger-ui', })","title":"OpenAPI Definition"},{"location":"pokeshop/","text":"Pokeshop Microservice API (PMA) As a testing ground, the team at Tracetest has implemented a sample instrumented API around the PokeAPI . The idea is to have a microservice-divided system that could behave like a typical scenario by having async processes (RabbitMQ), cache layers (Redis), database storage (Postgres), and simple CRUD interfaces for Pokemons. With this, users can get familiar with the Tracetest tool by focusing on creating assertions, visualizing the trace, and identifying the different data that comes from the Collector (Jeager). Users will learn about basic instrumentation practices like what tools to use, what data to send, when, and what suggested standards need to be followed. The PMA is only accessible from within the Kubernetes cluster network as the Tracetest needs to be able to reach it. System architecture","title":"Overview"},{"location":"pokeshop/#pokeshop-microservice-api-pma","text":"As a testing ground, the team at Tracetest has implemented a sample instrumented API around the PokeAPI . The idea is to have a microservice-divided system that could behave like a typical scenario by having async processes (RabbitMQ), cache layers (Redis), database storage (Postgres), and simple CRUD interfaces for Pokemons. With this, users can get familiar with the Tracetest tool by focusing on creating assertions, visualizing the trace, and identifying the different data that comes from the Collector (Jeager). Users will learn about basic instrumentation practices like what tools to use, what data to send, when, and what suggested standards need to be followed. The PMA is only accessible from within the Kubernetes cluster network as the Tracetest needs to be able to reach it.","title":"Pokeshop Microservice API (PMA)"},{"location":"pokeshop/#system-architecture","text":"","title":"System architecture"},{"location":"run-locally/","text":"Run Tracetest Locally Tracetest depends on a postgres database and a trace store backend (Jaeger or Tempo). The frontend requires node and npm and the backend requires the go tooling. Run on Local Kubernetes Tracetest and its dependencies can be installed in a local Kubernetes cluster (microk8s, minikube, Kubernetes for Docker Desktop, etc). Following the install steps will get a running instance of Tracetest and postgres. Installing Jaeger is the easiest way to get a trace store backend. The Tracetest install can be exposed with a LoadBalancer , NodePort or any similar mechanism. It can also be kept internally, only expose the Jaeger and postgres port, and use them to run local development builds. This is useful to quickly test changes on both the front and back end. Installing Jaeger Before installing Tracetest, we need to setup the Jaeger operator , which in turn has a dependency on cert-mnanager . cert-manager has different install options . The simplest way to do this is to use a static install: $ kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.8.0/cert-manager.yaml Once the pods in cert-manager namespace are running, we can install the Jaeger operator: kubectl create namespace observability kubectl create -f https://github.com/jaegertracing/jaeger-operator/releases/download/v1.32.0/jaeger-operator.yaml -n observability Now, create an AllInOne jaeger instance: cat <<EOF | kubectl create -f - apiVersion: jaegertracing.io/v1 kind: Jaeger metadata: name: jaeger EOF Install Tracetest Follow the install steps : helm repo add kubeshop https://kubeshop.github.io/helm-charts helm repo update helm install tracetest kubeshop/tracetest \\ --set tracingBackend=jaeger \\ --set jaegerConnectionConfig.endpoint=\"jaeger-query:16685\" You can now expose the Tracetest service using a LoadBalancer , NodePort or even a simple port-forward : kubectl port-forward svc/tracetest 8080:8080 Now Tracetest is available at [http://localhost:8080] Run a Development Build Now that Tracetest is running, we can expose the dependencies in our cluster to the host machine so they are accessible to the development build. Tracetests needs postgres to store the tests, results, etc, and access to the trace backend (jaeger, tempo, etc) to fetch traces. We can use kubectl's port forwarding capabilites for this (trap \"kill 0\" SIGINT; kubectl port-forward svc/tracetest-postgresql 5432:5432 & kubectl port-forward svc/jaeger-query 16685:16685) Start Development Server When running the development version, the frontend and backend are built and run separately. You need to have both services running to access the tool. To start the backend server: make server-run To start the frontend server: cd web npm install -d npm start The Tracetest development build is available at [http://localhost:3000]. Note that the port is now 3000 since we are accessing the node development server.","title":"Run Tracetest Locally"},{"location":"run-locally/#run-tracetest-locally","text":"Tracetest depends on a postgres database and a trace store backend (Jaeger or Tempo). The frontend requires node and npm and the backend requires the go tooling.","title":"Run Tracetest Locally"},{"location":"run-locally/#run-on-local-kubernetes","text":"Tracetest and its dependencies can be installed in a local Kubernetes cluster (microk8s, minikube, Kubernetes for Docker Desktop, etc). Following the install steps will get a running instance of Tracetest and postgres. Installing Jaeger is the easiest way to get a trace store backend. The Tracetest install can be exposed with a LoadBalancer , NodePort or any similar mechanism. It can also be kept internally, only expose the Jaeger and postgres port, and use them to run local development builds. This is useful to quickly test changes on both the front and back end.","title":"Run on Local Kubernetes"},{"location":"run-locally/#installing-jaeger","text":"Before installing Tracetest, we need to setup the Jaeger operator , which in turn has a dependency on cert-mnanager . cert-manager has different install options . The simplest way to do this is to use a static install: $ kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.8.0/cert-manager.yaml Once the pods in cert-manager namespace are running, we can install the Jaeger operator: kubectl create namespace observability kubectl create -f https://github.com/jaegertracing/jaeger-operator/releases/download/v1.32.0/jaeger-operator.yaml -n observability Now, create an AllInOne jaeger instance: cat <<EOF | kubectl create -f - apiVersion: jaegertracing.io/v1 kind: Jaeger metadata: name: jaeger EOF","title":"Installing Jaeger"},{"location":"run-locally/#install-tracetest","text":"Follow the install steps : helm repo add kubeshop https://kubeshop.github.io/helm-charts helm repo update helm install tracetest kubeshop/tracetest \\ --set tracingBackend=jaeger \\ --set jaegerConnectionConfig.endpoint=\"jaeger-query:16685\" You can now expose the Tracetest service using a LoadBalancer , NodePort or even a simple port-forward : kubectl port-forward svc/tracetest 8080:8080 Now Tracetest is available at [http://localhost:8080]","title":"Install Tracetest"},{"location":"run-locally/#run-a-development-build","text":"Now that Tracetest is running, we can expose the dependencies in our cluster to the host machine so they are accessible to the development build. Tracetests needs postgres to store the tests, results, etc, and access to the trace backend (jaeger, tempo, etc) to fetch traces. We can use kubectl's port forwarding capabilites for this (trap \"kill 0\" SIGINT; kubectl port-forward svc/tracetest-postgresql 5432:5432 & kubectl port-forward svc/jaeger-query 16685:16685)","title":"Run a Development Build"},{"location":"run-locally/#start-development-server","text":"When running the development version, the frontend and backend are built and run separately. You need to have both services running to access the tool. To start the backend server: make server-run To start the frontend server: cd web npm install -d npm start The Tracetest development build is available at [http://localhost:3000]. Note that the port is now 3000 since we are accessing the node development server.","title":"Start Development Server"},{"location":"websocket/","text":"Websocket endpoint Tracetest allow you to subscribe to updates of resources using websockets. There are two endpoints that you can use to manage subscriptions: Endpoint You can open a websocket connection by sending a request to port 8081 using the path /ws . Example: ws://localhost:8081/ws . Messages Subscribing to updates Once the connection is open, you can send a message with the format: { \"type\" : \"subscribe\" , \"resource\" : \"test/{testID}/result/{resultID}\" } If a problem happens, you will see an error like: { \"type\" : \"error\" , \"message\" : \"details of the error\" } If the operation executes successfully, you will see a response like: { \"type\" : \"success\" , \"message\" : { \"subscriptionId\" : \"bdbc6cc8-bba6-4208-a8d3-d3c2c5b3e38b\" } } The subscriptionId is an important field because it is required to cancel the subscription. You should store it, otherwise you will keep receiving updates of a resource that you might not want. Cancel a susbcription Once you have a subscription to a resource, you might want to stop receiving events from that resource. So, there is a unsubscribe message that you can send to achieve that. But send this message to the websocket connection: { \"type\" : \"unsubscribe\" , \"resource\" : \"test/{testID}/result/{resultID}\" , \"subscriptionId\" : \"id returned in the subscription command\" } You will receive an error message if any required field is not field. But in case of a successful operation, you will receive a message like: { \"type\" : \"success\" , \"message\" : \"ok\" } This message will be sent regardless if the subscription exists or not.","title":"Websocket endpoint"},{"location":"websocket/#websocket-endpoint","text":"Tracetest allow you to subscribe to updates of resources using websockets. There are two endpoints that you can use to manage subscriptions:","title":"Websocket endpoint"},{"location":"websocket/#endpoint","text":"You can open a websocket connection by sending a request to port 8081 using the path /ws . Example: ws://localhost:8081/ws .","title":"Endpoint"},{"location":"websocket/#messages","text":"","title":"Messages"},{"location":"websocket/#subscribing-to-updates","text":"Once the connection is open, you can send a message with the format: { \"type\" : \"subscribe\" , \"resource\" : \"test/{testID}/result/{resultID}\" } If a problem happens, you will see an error like: { \"type\" : \"error\" , \"message\" : \"details of the error\" } If the operation executes successfully, you will see a response like: { \"type\" : \"success\" , \"message\" : { \"subscriptionId\" : \"bdbc6cc8-bba6-4208-a8d3-d3c2c5b3e38b\" } } The subscriptionId is an important field because it is required to cancel the subscription. You should store it, otherwise you will keep receiving updates of a resource that you might not want.","title":"Subscribing to updates"},{"location":"websocket/#cancel-a-susbcription","text":"Once you have a subscription to a resource, you might want to stop receiving events from that resource. So, there is a unsubscribe message that you can send to achieve that. But send this message to the websocket connection: { \"type\" : \"unsubscribe\" , \"resource\" : \"test/{testID}/result/{resultID}\" , \"subscriptionId\" : \"id returned in the subscription command\" } You will receive an error message if any required field is not field. But in case of a successful operation, you will receive a message like: { \"type\" : \"success\" , \"message\" : \"ok\" } This message will be sent regardless if the subscription exists or not.","title":"Cancel a susbcription"},{"location":"working-with-traces/","text":"Working with Traces All tests will be listed in the dashboard: Select a test to see its trace details: Each run of the test is listed here along with the Execution Time, Status, Total Number of Assertions, Number of Assertions Passed, Number of Assertions Failed and Actions available for the test. Select a run of the test and the Tracetest dashboard will display:","title":"Working with Traces"},{"location":"working-with-traces/#working-with-traces","text":"All tests will be listed in the dashboard: Select a test to see its trace details: Each run of the test is listed here along with the Execution Time, Status, Total Number of Assertions, Number of Assertions Passed, Number of Assertions Failed and Actions available for the test. Select a run of the test and the Tracetest dashboard will display:","title":"Working with Traces"},{"location":"pokeshop/add-pokemon/","text":"Pokeshop - Add Pokemon Endpoint This endpoint showcases the different checkpoints that can be added to an application to include custom instrumentation such as validation of the incoming data before inserting it into the database. Endpoint specification Route: /pokemon Method: POST Request Body: { \"name\" : \"meowth\" , \"type\" : \"normal\" , \"imageUrl\" : \"https://assets.pokemon.com/assets/cms2/img/pokedex/full/052.png\" , \"isFeatured\" : true } Response: { \"id\" : 1000 , \"name\" : \"meowth\" , \"type\" : \"normal\" , \"imageUrl\" : \"https://assets.pokemon.com/assets/cms2/img/pokedex/full/052.png\" , \"isFeatured\" : true } Trace Details Assertions Here are some key points that are relevant to this query. Validate the Request Body is Valid To demonstrate the custom span capability from OTEL, this trace contains a checkpoint that validates the incoming request body before inserting the data into the database. To add an assertion to this checkpoint simply click the General span and then head into the custom tab where the custom attribute validation.isValid is displayed. Then click the add assertion button to open the form with the prefilled data. You\u2019ll see the check automatically added to the form, where the selectors and checks can be manually updated if necessary. To finalize the assertion creation just click the save button. Validate the Insert Database Statement To add an assertion to validate that the insert statement was executed with the proper information, we can start by selecting the database span and clicking the add assertion button. Then we can add one or multiple checks on the db.statement attribute to validate the different portions of the statement. After clicking save , the new assertion should show up.","title":"Add Pokemon Endpoint"},{"location":"pokeshop/add-pokemon/#pokeshop-add-pokemon-endpoint","text":"This endpoint showcases the different checkpoints that can be added to an application to include custom instrumentation such as validation of the incoming data before inserting it into the database.","title":"Pokeshop - Add Pokemon Endpoint"},{"location":"pokeshop/add-pokemon/#endpoint-specification","text":"Route: /pokemon Method: POST Request Body: { \"name\" : \"meowth\" , \"type\" : \"normal\" , \"imageUrl\" : \"https://assets.pokemon.com/assets/cms2/img/pokedex/full/052.png\" , \"isFeatured\" : true } Response: { \"id\" : 1000 , \"name\" : \"meowth\" , \"type\" : \"normal\" , \"imageUrl\" : \"https://assets.pokemon.com/assets/cms2/img/pokedex/full/052.png\" , \"isFeatured\" : true }","title":"Endpoint specification"},{"location":"pokeshop/add-pokemon/#trace-details","text":"","title":"Trace Details"},{"location":"pokeshop/add-pokemon/#assertions","text":"Here are some key points that are relevant to this query. Validate the Request Body is Valid To demonstrate the custom span capability from OTEL, this trace contains a checkpoint that validates the incoming request body before inserting the data into the database. To add an assertion to this checkpoint simply click the General span and then head into the custom tab where the custom attribute validation.isValid is displayed. Then click the add assertion button to open the form with the prefilled data. You\u2019ll see the check automatically added to the form, where the selectors and checks can be manually updated if necessary. To finalize the assertion creation just click the save button. Validate the Insert Database Statement To add an assertion to validate that the insert statement was executed with the proper information, we can start by selecting the database span and clicking the add assertion button. Then we can add one or multiple checks on the db.statement attribute to validate the different portions of the statement. After clicking save , the new assertion should show up.","title":"Assertions"},{"location":"pokeshop/import-pokemon/","text":"Pokeshop - Import Pokemon Endpoint This endpoint showcases a more complex scenario involving an async process. Usually, when working with microservices, there are use cases where some of the processing needs to happen asynchronously, for example, when triggering a user notification, generating reports, or processing a payment order. With this endpoint, we provide an example of how users can implement trace-based testing for such scenarios. Endpoint specification Route: /pokemon/import Method: POST Request Body: { \"id\" : 1 } Response: { \"id\" : 1000 , \"name\" : \"meowth\" , \"type\" : \"normal\" , \"imageUrl\" : \"https://assets.pokemon.com/assets/cms2/img/pokedex/full/052.png\" , \"isFeatured\" : true } Trace Assertions Here are some key points that are relevant to this query. Validate the Message Is Sent to the Cue To validate what\u2019s being sent from the API to the worker, we can click the custom queue producer span and validate the messaging.payload attribute exists under the custom tab. To add an assertion targeting this attribute, we can select the add assertion icon that shows up while hovering over it. After that, we can tweak the assertion to match the expected value from the attribute. Clicking add should show the newly created assertion. Validate the Message Is Processed by the Worker The next thing would be to add an assertion related to the worker receiving the message and starting to process the job. We can achieve this by validating that the custom checkpoint for the worker exists. In this case, we can click the import pokemon general span, then click on the add assertion button. After this is done, we can proceed to add checks for the service.name and process.command attributes that should match the specific worker metadata. Clicking save should display the newly created assertion Validate the PokeAPI HTTP Data Information After validating that the message has arrived at the worker, we can start adding assertions to the different steps. The first one is requesting the pokemon information from the poke API, here we can add multiple checks in regards to url, routes, response, status, etc. After having selected the worker HTTP span and clicking the add assertion button, we can start modifying the different checks. Clicking save should show the assertion: Validate HTTP Spans Status Code With Tracetest you can also add checks for not only one but multiple spans. In this case, we\u2019ll be adding an assertion that will affect every HTTP span to validate that the http.status_code is equal 200 . To start this process, click on any of the HTTP spans and then the add assertion button. Then remove the different selector entries from the first input until the only remaining one is the tracetest.span.type . The last step is to add our check using the http.status_code and match it against the 200 value. You\u2019ll see the 2 affected spans message at the top right of the form. By clicking save , it will be shown in the main assertions area. Validate the Insert Database Statement Last but not least, we can add a validation to check if the record was saved to the database by selecting the custom Postgres span and clicking add an assertion . Then we can add checks for both the db.operation to match create and the result to match the JSON expected object. Clicking save will display the new assertion.","title":"Import Pokemon Endpoint"},{"location":"pokeshop/import-pokemon/#pokeshop-import-pokemon-endpoint","text":"This endpoint showcases a more complex scenario involving an async process. Usually, when working with microservices, there are use cases where some of the processing needs to happen asynchronously, for example, when triggering a user notification, generating reports, or processing a payment order. With this endpoint, we provide an example of how users can implement trace-based testing for such scenarios.","title":"Pokeshop - Import Pokemon Endpoint"},{"location":"pokeshop/import-pokemon/#endpoint-specification","text":"Route: /pokemon/import Method: POST Request Body: { \"id\" : 1 } Response: { \"id\" : 1000 , \"name\" : \"meowth\" , \"type\" : \"normal\" , \"imageUrl\" : \"https://assets.pokemon.com/assets/cms2/img/pokedex/full/052.png\" , \"isFeatured\" : true }","title":"Endpoint specification"},{"location":"pokeshop/import-pokemon/#trace","text":"","title":"Trace"},{"location":"pokeshop/import-pokemon/#assertions","text":"Here are some key points that are relevant to this query. Validate the Message Is Sent to the Cue To validate what\u2019s being sent from the API to the worker, we can click the custom queue producer span and validate the messaging.payload attribute exists under the custom tab. To add an assertion targeting this attribute, we can select the add assertion icon that shows up while hovering over it. After that, we can tweak the assertion to match the expected value from the attribute. Clicking add should show the newly created assertion. Validate the Message Is Processed by the Worker The next thing would be to add an assertion related to the worker receiving the message and starting to process the job. We can achieve this by validating that the custom checkpoint for the worker exists. In this case, we can click the import pokemon general span, then click on the add assertion button. After this is done, we can proceed to add checks for the service.name and process.command attributes that should match the specific worker metadata. Clicking save should display the newly created assertion Validate the PokeAPI HTTP Data Information After validating that the message has arrived at the worker, we can start adding assertions to the different steps. The first one is requesting the pokemon information from the poke API, here we can add multiple checks in regards to url, routes, response, status, etc. After having selected the worker HTTP span and clicking the add assertion button, we can start modifying the different checks. Clicking save should show the assertion: Validate HTTP Spans Status Code With Tracetest you can also add checks for not only one but multiple spans. In this case, we\u2019ll be adding an assertion that will affect every HTTP span to validate that the http.status_code is equal 200 . To start this process, click on any of the HTTP spans and then the add assertion button. Then remove the different selector entries from the first input until the only remaining one is the tracetest.span.type . The last step is to add our check using the http.status_code and match it against the 200 value. You\u2019ll see the 2 affected spans message at the top right of the form. By clicking save , it will be shown in the main assertions area. Validate the Insert Database Statement Last but not least, we can add a validation to check if the record was saved to the database by selecting the custom Postgres span and clicking add an assertion . Then we can add checks for both the db.operation to match create and the result to match the JSON expected object. Clicking save will display the new assertion.","title":"Assertions"},{"location":"pokeshop/list-pokemon/","text":"Pokeshop - List Pokemons Endpoint This endpoint returns the list of Pokemon directly from the database (Postgres) based on the provided query. The idea of this query is to showcase a straightforward scenario, where the API layer receives a request from the outside and needs to trigger a database query to get some data and return it to the client. Endpoint specification Route: /pokemon?take=20&skip=0 Method: GET Response: [ { \"id\" : 25 , \"name\" : \"pikachu\" , \"type\" : \"electric\" , \"imageUrl\" : \"https://assets.pokemon.com/assets/cms2/img/pokedex/full/025.png\" , \"isFeatured\" : true }, { \"id\" : 26 , \"name\" : \"raichu\" , \"type\" : \"electric\" , \"imageUrl\" : \"https://assets.pokemon.com/assets/cms2/img/pokedex/full/026.png\" , \"isFeatured\" : true } ] Trace Assertions Here are some key points that are relevant for this query. Validating the Database Query Speed To add a validation based on a span duration, we can click the specific database span we want to add the test to. After clicking the add assertion button which will display the form, based on the predefined selector, we can start adding the assertions at the bottom. Tracetest adds a custom attribute to all spans called tracetest.span.duration which contains the duration in milliseconds. By selecting that attribute, we can now add the operator and value we want to use. In this case, we are checking that the duration is less than 5 milliseconds. The next step is selecting add and then the assertion should show up in the bottom section as draft mode. Validate the Resulting Body To validate the resulting body we can use one of the attributes coming from the inbound HTTP request called http.response.body . A different way to open the assertion form with prefilled data is by clicking the add assertion plus sign from the span detail attribute section. This way the assertion form will have the selected attribute added as a check from the start. We can compare it directly by using equals or using contains to match a substring. After selecting add it should show as part of the assertions in edit mode. Validate the Database Statement to Include the Query Parameters To achieve this, we can add an assertion targeting the select query span to contain the limit and offset parameters. To do that we need to select the specific span and click add assertion, we can add a check for the db.statement to contain LIMIT 20 OFFSET 0 like: And by selecting add it should show up like this:","title":"List Pokemon Endpoints"},{"location":"pokeshop/list-pokemon/#pokeshop-list-pokemons-endpoint","text":"This endpoint returns the list of Pokemon directly from the database (Postgres) based on the provided query. The idea of this query is to showcase a straightforward scenario, where the API layer receives a request from the outside and needs to trigger a database query to get some data and return it to the client.","title":"Pokeshop - List Pokemons Endpoint"},{"location":"pokeshop/list-pokemon/#endpoint-specification","text":"Route: /pokemon?take=20&skip=0 Method: GET Response: [ { \"id\" : 25 , \"name\" : \"pikachu\" , \"type\" : \"electric\" , \"imageUrl\" : \"https://assets.pokemon.com/assets/cms2/img/pokedex/full/025.png\" , \"isFeatured\" : true }, { \"id\" : 26 , \"name\" : \"raichu\" , \"type\" : \"electric\" , \"imageUrl\" : \"https://assets.pokemon.com/assets/cms2/img/pokedex/full/026.png\" , \"isFeatured\" : true } ]","title":"Endpoint specification"},{"location":"pokeshop/list-pokemon/#trace","text":"","title":"Trace"},{"location":"pokeshop/list-pokemon/#assertions","text":"Here are some key points that are relevant for this query. Validating the Database Query Speed To add a validation based on a span duration, we can click the specific database span we want to add the test to. After clicking the add assertion button which will display the form, based on the predefined selector, we can start adding the assertions at the bottom. Tracetest adds a custom attribute to all spans called tracetest.span.duration which contains the duration in milliseconds. By selecting that attribute, we can now add the operator and value we want to use. In this case, we are checking that the duration is less than 5 milliseconds. The next step is selecting add and then the assertion should show up in the bottom section as draft mode. Validate the Resulting Body To validate the resulting body we can use one of the attributes coming from the inbound HTTP request called http.response.body . A different way to open the assertion form with prefilled data is by clicking the add assertion plus sign from the span detail attribute section. This way the assertion form will have the selected attribute added as a check from the start. We can compare it directly by using equals or using contains to match a substring. After selecting add it should show as part of the assertions in edit mode. Validate the Database Statement to Include the Query Parameters To achieve this, we can add an assertion targeting the select query span to contain the limit and offset parameters. To do that we need to select the specific span and click add assertion, we can add a check for the db.statement to contain LIMIT 20 OFFSET 0 like: And by selecting add it should show up like this:","title":"Assertions"}]}